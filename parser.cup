/*
   Grammaire attribuée pour construire l'arbre abstrait correspondant au langage Block
*/

package fr.n7.stl.minijava;

import java_cup.runtime.*;
import fr.n7.stl.minijava.Lexer;
import java.io.*;
import java.util.*;

// Elements du métamodèle pour la construction de l'arbre abstrait
import fr.n7.stl.minijava.ast.*;
import fr.n7.stl.minijava.ast.expression.*;
import fr.n7.stl.minijava.ast.expression.accessible.*;
import fr.n7.stl.minijava.ast.expression.allocation.*;
import fr.n7.stl.minijava.ast.expression.assignable.*;
import fr.n7.stl.minijava.ast.expression.value.*;
import fr.n7.stl.minijava.ast.instruction.*;
import fr.n7.stl.minijava.ast.instruction.declaration.*;
import fr.n7.stl.minijava.ast.scope.*;
import fr.n7.stl.minijava.ast.type.*;
import fr.n7.stl.minijava.ast.type.declaration.*;
import fr.n7.stl.minijava.ast.objet.*;
import fr.n7.stl.minijava.ast.objet.declaration.*;
import fr.n7.stl.minijava.ast.objet.definition.*;
import fr.n7.stl.util.*;
import fr.n7.stl.tam.ast.*;

/* Variables partagées dans les actions de l'analyseur syntaxique. */
parser code {:
	protected Lexer lexer;
	protected String name;
	protected String entCour;
	protected String nomCourant;
	
	protected ObjetDeclaration objetCourant;

	public Parser(String _name) {
		this();
		this.name = _name;
		this.nomCourant = "";
		this.entCour = "";
		this.objetCourant = null;
	}
:}

/* Initialisation de l'analyseur lexical et des variables partagées. */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File(this.name);
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};

/* Expression qui permet de progresser dans l'analyse lexicale. */
scan with {: return lexer.next_token(); :};

/* Terminaux qui seront transmis par l'analyseur lexical. */
terminal 			UL_Point_Virgule, UL_Virgule, UL_Point, UL_Deux_Points, UL_Point_Interrogation, UL_Point_Exclamation;
terminal				UL_Egal, UL_Double_Plus, UL_Double_Moins, UL_Double_Plus_Prefixe, UL_Double_Moins_Prefixe;
terminal 			UL_Plus, UL_Moins, UL_Moins_Unaire, UL_Asterisque, UL_Oblique, UL_Pour_Cent;
terminal				UL_Esperluette, UL_Double_Barre, UL_Double_Esperluette;
terminal				UL_Parenthese_Ouvrante, UL_Parenthese_Fermante;
terminal				UL_Premier, UL_Second;
terminal				UL_Accolade_Ouvrante, UL_Accolade_Fermante;
terminal				UL_Crochet_Ouvrant, UL_Crochet_Fermant;
terminal				UL_Inferieur, UL_Superieur;
terminal				UL_Inferieur_Egal, UL_Superieur_Egal;
terminal				UL_Double_Egal, UL_Exclamation_Egal;
terminal				UL_Si, UL_Sinon, UL_Tant_Que, UL_Nouveau, UL_Afficher, UL_Retour;

// GRAMMAIRE DE MINIJAVA 
terminal                UL_Interface, UL_Class;
terminal                UL_Extends, UL_Implements;
terminal                UL_Final, UL_Abstract, UL_Public, UL_Private, UL_Static;
terminal                UL_Main, UL_This;
terminal				UL_Definition_Constante, UL_Definition_Type, UL_Enregistrement, UL_Enumeration;
terminal				UL_Type_Booleen, UL_Type_Caractere, UL_Type_Chaine, UL_Type_Entier, UL_Type_Flottant, UL_Type_Vide;
terminal String		    UL_Identificateur, UL_Chaine, UL_Caractere;
terminal String		    UL_Nombre_Entier, UL_Nombre_Flottant, UL_Nul, UL_Vrai, UL_Faux; // Valeur transmise par l'analyseur lexical

/* Non terminaux avec type renvoyé par actions sémantiques (RESULT = ...) */
//non terminal Block						Program;
non terminal Block						Bloc; 
non terminal List<Instruction>			Instructions; 
non terminal Instruction				Instruction;
non terminal Instruction				Declaration;
non terminal List<Expression>			Expressions;
non terminal List<FieldDeclaration>		Champs;
non terminal FieldDeclaration			Champ;
non terminal List<LabelDeclaration>		Etiquettes;
non terminal LabelDeclaration			Etiquette;
non terminal List<ParameterDeclaration>	Parameters;
non terminal Pair<String,PartialType>	Identifiant;
non terminal Type						Type, Atomique;
non terminal Expression 				Expression;
non terminal AssignableExpression		Affectable;

// Définir ici les non terminaux
non terminal List<ObjetDeclaration>     Programme;
non terminal List<ObjetDeclaration>     Objets;
non terminal ObjetDeclaration    	    Objet;
non terminal MainClasseDeclaration      MainClasse;
non terminal String                     Interface;
non terminal String          		    Classe;
non terminal Definition                 Definition;
non terminal List<Definition>           Definitions;
non terminal MainMethodeDeclaration     MainMethode;
non terminal Entete                     Entete; // OK
non terminal List<Entete>               Entetes;

// TODO
//non terminal Expression   		  Extension;
non terminal Instanciation			  Instanciation;
//non terminal List<Instanciation>    Instanciations;

//non terminal List<ParameterDeclaration>	Parameters; OK AVEC L'ANCIEN
//non terminal Type                     Type; // OK avec l'ancien

//non terminal Instruction              ListeIdentiteExtends; // Declaration : ident < ListeIdentiteExtends >
//non terminal Instruction              ListeInstanciationsEsperluette; // ListeIdentiteExtends : ident extends LIEsp



/* Associativité et Priorité relative des opérateurs (du moins prioritaire au plus prioritaire) */
/* Opérateur le moins prioritiaire */	
precedence nonassoc UL_Identificateur;	// Résolution du conflit décaler/réduire sur conversion de type
precedence right UL_Egal;
precedence nonassoc UL_Point_Interrogation, UL_Deux_Points;
precedence left UL_Double_Barre;
precedence left UL_Double_Esperluette;
precedence nonassoc UL_Double_Egal, UL_Exclamation_Egal;
precedence nonassoc UL_Inferieur, UL_Inferieur_Egal, UL_Superieur, UL_Superieur_Egal;
precedence left UL_Plus, UL_Moins;
precedence left UL_Asterisque, UL_Oblique, UL_Pour_Cent;
precedence right UL_Nouveau;
precedence left UL_Premier, UL_Second;
precedence left UL_Double_Plus_Prefixe, UL_Double_Moins_Prefixe, UL_Moins_Unaire, UL_Esperluette, UL_Point_Exclamation;
precedence nonassoc UL_Double_Plus, UL_Double_Moins;
precedence left UL_Crochet_Ouvrant, UL_Point, UL_Parenthese_Ouvrante;
/* Opérateur le plus prioritaire */

/* Règles de grammaire attribuée pour la construction de l'arbre abstrait */
/* Program et Bloc sont des non terminaux */
/* UL_Identificateur est un terminal (Unité lexicale) */
/* bloc est la variable utilisable dans l'action sémantique qui contient la valeur renvoyé par l'analyse du Bloc */
/*Program ::= UL_Identificateur:nom Bloc:bloc
			{: 
				System.out.println( "Programme nommé " + nom );
				System.out.println( bloc ); 
				SymbolTable tds = new SymbolTable();
				if (bloc.resolve(tds)) {
					System.out.println("TDS OK" + tds);
					if (bloc.checkType()) {
						System.out.println("Type OK");
						bloc.allocateMemory(Register.SB,0);
						String code = bloc.getCode(new fr.n7.stl.tam.ast.impl.TAMFactoryImpl()).toString();
						try {
							PrintWriter output = new PrintWriter( new FileWriter( new File(".tam" )));
						} catch (IOException e) {
							// TODO Auto-generated catch minijava
							e.printStackTrace();
						}
					} else {
						System.out.println("Type KO");
					}
				} else {
					System.out.println("KO" + tds);
				}
			:}
		;
*/

/**
	Un fichier représente plusieurs objets d'affilés
*/

Programme ::= MainClasse:mainClasse Objets:objets 
			{:
				System.out.println("Nouveau programme : ");
				//System.out.println(mainClasse);				
				
				SymbolTable tds = new SymbolTable();
			   
				for(ObjetDeclaration objet : objets){
					System.out.println(objet.getName() + " : ");
					if(objet.resolve(tds)){
						System.out.println("\tRESOLVE : OK");
						
						if(objet.checkType()){
							System.out.println("\tCHECK TYPE : OK");
						} else {
							System.out.println("\tCHECK TYPE : KO");
						}		


					} else {
						System.out.println("\tRESOLVE : KO");
					}	
				}
				
				System.out.println(mainClasse.getName() + " : ");
				if(mainClasse.resolve(tds)){
			
					System.out.println("\tRESOLVE : OK");

					if(mainClasse.checkType()){
						System.out.println("\tCHECK TYPE : OK");
					} else {
						System.out.println("\tCHECK TYPE : KO");
					}
	
				} else {
					System.out.println("\tRESOLVE : KO");
				}

				

		
				
				System.out.println("\n\n"); 
				System.out.println(tds.toString());
			:} 
			| MainClasse:mainClasse
			{:
				System.out.println("Programme : ");
				//System.out.println(mainClasse);
				SymbolTable tds = new SymbolTable();	
				
				System.out.println(mainClasse.getName() + " : ");
				if(mainClasse.resolve(tds)){
					System.out.println("\tRESOLVE : OK");

					if(mainClasse.checkType()){
						System.out.println("\tCHECK TYPE : OK");
					} else {
						System.out.println("\tCHECK TYPE : KO");
					}
				} else {
					System.out.println("\tRESOLVE : KO");
				}		
			:} 
			;


Objets ::= Objets:objets Objet:objet
			{:
				objets.add(objet); 
				RESULT = objets; 	
			:}
			| Objet:objet
			{:
				List<ObjetDeclaration> _objets = new LinkedList<ObjetDeclaration>(); 
				_objets.add(objet); 
				RESULT = _objets; 
			:}
			;
/*
Objet :
- TODO: interface declaration extends instanciations { entetes }
- TODO: interface declaration { entetes }
- TODO: class declaration extension { definition }
- TODO: final class declaration extension { definition }
- TODO: abstract class declaration extension { definition }
*/ 
Objet ::=     UL_Interface Interface:nom /*UL_Extends Instanciations:instanciations*/ UL_Accolade_Ouvrante  Entetes:entetes UL_Accolade_Fermante
				{: 
					objetCourant = new InterfaceDeclaration(nom, entetes);
					RESULT = objetCourant;
				:}
			  /*| UL_Interface Interface:declaration UL_Accolade_Ouvrante Entetes:entetes UL_Accolade_Fermante
				{: 
					RESULT = new Interface(declaration, entetes);
				:}*/ 
			  | UL_Interface Interface:nom /*UL_Extends Instanciations:instanciations */ UL_Accolade_Ouvrante UL_Accolade_Fermante
				{: 
					objetCourant = new InterfaceDeclaration(nom, null);
					RESULT = objetCourant;
				:}
			  /*| UL_Interface Interface:declaration UL_Accolade_Ouvrante UL_Accolade_Fermante
				{: 
					RESULT = new Interface(declaration);
				:} */
			  | UL_Class Classe:nom /*Extension:extension*/ UL_Accolade_Ouvrante Definitions:definitions UL_Accolade_Fermante
				{: 
					objetCourant = new ClasseDeclaration(nom, definitions);
					RESULT = objetCourant;
				:}
			  | UL_Final UL_Class Classe:nom /*Extension:extension*/ UL_Accolade_Ouvrante Definitions:definitions UL_Accolade_Fermante
				{:	
					objetCourant = new ClasseDeclaration(nom, definitions);
					RESULT = objetCourant;
				:}
			  | UL_Abstract UL_Class Classe:nom /*Extension:extension*/ UL_Accolade_Ouvrante Definitions:definitions UL_Accolade_Fermante
				{: 
					objetCourant = new ClasseDeclaration(nom, Keyword.ABSTRACT, definitions);
					RESULT = objetCourant;
				:}	
			  | UL_Class Classe:nom /*Extension:extension*/ UL_Accolade_Ouvrante UL_Accolade_Fermante
				{: 
					objetCourant = new ClasseDeclaration(nom, null);
					RESULT = objetCourant;
				:}
			  | UL_Final UL_Class Classe:nom /*Extension:extension*/ UL_Accolade_Ouvrante UL_Accolade_Fermante
				{:
					objetCourant = new ClasseDeclaration(nom, null);
					RESULT = objetCourant;
				:}
			  | UL_Abstract UL_Class Classe:nom /*Extension:extension*/ UL_Accolade_Ouvrante UL_Accolade_Fermante
				{: 
					objetCourant = new ClasseDeclaration(nom, Keyword.ABSTRACT, null);
					RESULT = objetCourant;
				:}	   
			   ;

MainMethode ::= UL_Public UL_Static UL_Type_Vide UL_Main UL_Parenthese_Ouvrante Parameters:parametres UL_Parenthese_Fermante Bloc:corps
				{:
					RESULT = new MainMethodeDeclaration(parametres, corps);
				:}
				| UL_Public UL_Static UL_Type_Vide UL_Main UL_Parenthese_Ouvrante UL_Parenthese_Fermante Bloc:corps
				{:
					RESULT = new MainMethodeDeclaration(corps);
				:};
		
		
Interface ::= UL_Identificateur:nom
			{:
				RESULT = nom;
			:}
			 /* | UL_Identificateur:nom UL_Inferieur ListeIdentiteExtends UL_Superieur {::}
		 	*/
		 	;		

MainClasse ::= UL_Class UL_Identificateur:nom UL_Accolade_Ouvrante MainMethode:main UL_Accolade_Fermante
			  {:
					nomCourant = nom;
					RESULT = new MainClasseDeclaration(nom, main);
			  :}
			  ;	 

Classe ::=  UL_Identificateur:nom
			{:
				nomCourant = nom;
				RESULT = nom;
			:}
			  /* | UL_Identificateur:nom UL_Inferieur ListeIdentiteExtends UL_Superieur {::}
		 	*/
		 	;
/*
ListeIdentiteExtends ::= Identifiant:identifiant {::}
						 | Identifiant:identifiant UL_Extends ListeInstanciationsEsperluette {::}
						 | Identifiant:identifiant UL_Virgule ListeIdentiteExtends {::}
						 | Identifiant:identifiant UL_Extends ListeInstanciationsEsperluette UL_Virgule 
						 	ListeIdentiteExtends{::}
						 ;

ListeIdentiteExtends ::= Instanciation:instanciation {::}
					     | Instanciation:instanciation UL_Esperluette ListeIdentiteExtends {::}
					     ;
	     
Extension ::= UL_Extends Instanciation:instanciation {::}
			  | UL_Extends Instanciation:instanciation UL_Implements Instanciations:instanciations {::}
			  | UL_Implements Instanciations:instanciations {::}
			  ;
*/	
Definition ::= 	/* ATTRIBUTS */
				UL_Public Type:type Identifiant:identifiant UL_Point_Virgule  
				{:
					Type _type = identifiant.getRight();
					if (_type == null) {
						_type = type;
					} else {
						_type = ((PartialType)_type).complete( type );
 					}

					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PUBLIC);
					RESULT = new AttributDeclaration(keywords, _type, nomCourant, identifiant.getLeft());
				:}
				| UL_Private Type:type Identifiant:identifiant UL_Point_Virgule  
				{:
					Type _type = identifiant.getRight();
					if (_type == null) {
						_type = type;
					} else {
						_type = ((PartialType)_type).complete( type );
 					}
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PRIVATE);
					RESULT = new AttributDeclaration(keywords, _type,  nomCourant, identifiant.getLeft());
				:}
				| UL_Public UL_Static Type:type Identifiant:identifiant UL_Point_Virgule
				{:
					Type _type = identifiant.getRight();
					if (_type == null) {
						_type = type;
					} else {
						_type = ((PartialType)_type).complete( type );
 					}
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PUBLIC);
					keywords.add(Keyword.STATIC);
					RESULT = new AttributDeclaration(keywords, _type,  nomCourant, identifiant.getLeft());
				:}
				| UL_Private UL_Static Type:type Identifiant:identifiant UL_Point_Virgule
				{:
					Type _type = identifiant.getRight();
					if (_type == null) {
						_type = type;
					} else {
						_type = ((PartialType)_type).complete( type );
 					}
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PRIVATE);
					keywords.add(Keyword.STATIC);
					RESULT = new AttributDeclaration(keywords, _type,  nomCourant, identifiant.getLeft());
				:}
				| UL_Public UL_Final Type:type Identifiant:identifiant UL_Point_Virgule 
				{:
					Type _type = identifiant.getRight();
					if (_type == null) {
						_type = type;
					} else {
						_type = ((PartialType)_type).complete( type );
 					}
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PUBLIC);
					keywords.add(Keyword.FINAL);
					RESULT = new AttributDeclaration(keywords, _type, nomCourant, identifiant.getLeft());
				:}
				| UL_Private UL_Final Type:type Identifiant:identifiant UL_Point_Virgule
				{:
					Type _type = identifiant.getRight();
					if (_type == null) {
						_type = type;
					} else {
						_type = ((PartialType)_type).complete( type );
 					}
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PRIVATE);
					keywords.add(Keyword.FINAL);
					RESULT = new AttributDeclaration(keywords, _type, nomCourant, identifiant.getLeft());
				:}
				| UL_Public UL_Static UL_Final Type:type Identifiant:identifiant UL_Point_Virgule
				{:
					Type _type = identifiant.getRight();
					if (_type == null) {
						_type = type;
					} else {
						_type = ((PartialType)_type).complete( type );
 					}
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PUBLIC);
					keywords.add(Keyword.STATIC);
					keywords.add(Keyword.FINAL);
					RESULT = new AttributDeclaration(keywords, _type, nomCourant, identifiant.getLeft());
				:}
				| UL_Private UL_Static UL_Final Type:type Identifiant:identifiant UL_Point_Virgule
				{:
					Type _type = identifiant.getRight();
					if (_type == null) {
						_type = type;
					} else {
						_type = ((PartialType)_type).complete( type );
 					}
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PRIVATE);
					keywords.add(Keyword.STATIC);
					keywords.add(Keyword.FINAL);
					RESULT = new AttributDeclaration(keywords, _type, nomCourant, identifiant.getLeft());
				:}
				/* METHODES */
				| UL_Public Entete:entete Bloc:bloc
				{:
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PUBLIC);
					RESULT = new MethodeDeclaration(keywords, entete, bloc);
				:}
				| UL_Private Entete:entete Bloc:bloc
				{:
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PRIVATE);
					RESULT = new MethodeDeclaration(keywords, entete, bloc);
				:}
				| UL_Public UL_Static Entete:entete Bloc:bloc
				{:
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PUBLIC);
					keywords.add(Keyword.STATIC);
					RESULT = new MethodeDeclaration(keywords, entete, bloc);
				:}
				| UL_Private UL_Static Entete:entete Bloc:bloc
				{:
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PRIVATE);
					keywords.add(Keyword.STATIC);
					RESULT = new MethodeDeclaration(keywords, entete, bloc);
				:}
				| UL_Public UL_Abstract Entete:entete Bloc:bloc
				{:
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PUBLIC);
					keywords.add(Keyword.ABSTRACT);
					RESULT = new MethodeDeclaration(keywords, entete, bloc);
				:}
				| UL_Private UL_Abstract Entete:entete Bloc:bloc
				{:
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PRIVATE);
					keywords.add(Keyword.ABSTRACT);
					RESULT = new MethodeDeclaration(keywords, entete, bloc);
				:}
				| UL_Public UL_Static UL_Abstract Entete:entete Bloc:bloc
				{:
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PUBLIC);
					keywords.add(Keyword.STATIC);
					keywords.add(Keyword.ABSTRACT);
					RESULT = new MethodeDeclaration(keywords, entete, bloc);
				:}
				| UL_Private UL_Static UL_Abstract Entete:entete Bloc:bloc
				{:
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PRIVATE);
					keywords.add(Keyword.STATIC);
					keywords.add(Keyword.ABSTRACT);

					RESULT = new MethodeDeclaration(keywords, entete, bloc);
				:}
				| UL_Public UL_Final Entete:entete Bloc:bloc
				{:
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PUBLIC);
					keywords.add(Keyword.FINAL);

					RESULT = new MethodeDeclaration(keywords, entete, bloc);
				:}
				| UL_Private UL_Final Entete:entete Bloc:bloc
				{:
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PRIVATE);
					keywords.add(Keyword.FINAL);
					RESULT = new MethodeDeclaration(keywords, entete, bloc);
				:}
				| UL_Public UL_Static UL_Final Entete:entete Bloc:bloc
				{:
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PUBLIC);
					keywords.add(Keyword.STATIC);
					keywords.add(Keyword.FINAL);
					RESULT = new MethodeDeclaration(keywords, entete, bloc);
				:}
				| UL_Private UL_Static UL_Final Entete:entete Bloc:bloc
				{:
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PRIVATE);
					keywords.add(Keyword.STATIC);
					keywords.add(Keyword.FINAL);
					RESULT = new MethodeDeclaration(keywords, entete, bloc);
				:}
				| UL_Public UL_Identificateur:nom UL_Parenthese_Ouvrante UL_Parenthese_Fermante Bloc:corps
				{:
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PUBLIC);
					RESULT = new ConstructeurDeclaration(keywords, nomCourant, nom, corps, null);
				:}	
				| UL_Private UL_Identificateur:nom UL_Parenthese_Ouvrante UL_Parenthese_Fermante Bloc:corps
				{:
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PRIVATE);
					RESULT = new ConstructeurDeclaration(keywords, nomCourant, nom, corps, null);
				:}
				| UL_Public UL_Identificateur:nom UL_Parenthese_Ouvrante Parameters:parametres UL_Parenthese_Fermante Bloc:corps
				{:
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PUBLIC);
					RESULT = new ConstructeurDeclaration(keywords, nomCourant, nom, corps, parametres);
				:}	
				| UL_Private UL_Identificateur:nom UL_Parenthese_Ouvrante Parameters:parametres UL_Parenthese_Fermante Bloc:corps
				{:
					List<Keyword> keywords = new ArrayList<Keyword>();
					keywords.add(Keyword.PRIVATE);
					RESULT = new ConstructeurDeclaration(keywords, nomCourant, nom, corps, parametres);
				:}					
				; 
		  
Definitions ::= Definitions:definitions Definition:definition 
				{:
					definitions.add(definition);
					RESULT = definitions;
				:}
				| Definition:definition
				{:
					List<Definition> _definitions = new LinkedList<Definition>(); 
					_definitions.add(definition); 
					RESULT = _definitions; 
				:}
				;

Instanciation ::= UL_Identificateur:ident 
				{:
					RESULT = new Instanciation(ident);
				:} 
				 //|Identifiant:identifiant UL_Inferieur Instanciations:instanciations UL_Superieur {::}
				;
/*
Instanciations ::= Instanciation:instanciation {::}
				   | Instanciation:instanciation UL_Virgule Instanciations:instanciations {::}
				   ;
*/

Entete ::=   UL_Type_Vide UL_Identificateur:nom UL_Parenthese_Ouvrante UL_Parenthese_Fermante 
			{:
				entCour = nom;
				RESULT = new Entete(nom, nomCourant, AtomicType.VoidType, null);
			:}
		   | UL_Type_Vide UL_Identificateur:nom UL_Parenthese_Ouvrante Parameters:parametres UL_Parenthese_Fermante 
		   {:
				entCour = nom;
				RESULT = new Entete(nom,nomCourant, AtomicType.VoidType, parametres);
			:}
		   | Type:type UL_Identificateur:nom UL_Parenthese_Ouvrante UL_Parenthese_Fermante 
		   {:	
				entCour = nom;
				RESULT = new Entete(nom, nomCourant, type, null);
			:}
		   | Type:type UL_Identificateur:nom UL_Parenthese_Ouvrante Parameters:parametres UL_Parenthese_Fermante 
		   {:
				entCour = nom;
				RESULT = new Entete(nom, nomCourant, type, parametres);
			:}
		   ;

Entetes ::= Entete:entete UL_Point_Virgule Entetes:entetes 
			{:
				entetes.add(entete);
				RESULT = entetes;
			:}
			| Entete:entete UL_Point_Virgule
			{:
				List<Entete> _entetes = new ArrayList<Entete>();
				_entetes.add(entete);
				RESULT = _entetes;
			:};
			
Bloc ::= UL_Accolade_Ouvrante Instructions:instructions UL_Accolade_Fermante 
			{: 
				RESULT = new Block( instructions ); 
			:}
		;
		
Champ ::= Type:type Identifiant:identifiant UL_Point_Virgule 
			{: 
				Type _type = identifiant.getRight();
				if (_type == null) {
					_type = type;
				} else {
					_type = ((PartialType)_type).complete( type );
 				}
				RESULT = new FieldDeclaration( identifiant.getLeft(), _type);
			:}
		;
		
Champs ::= Champs:champs Champ:champ
			{: 
				champs.add(champ); 
				RESULT = champs; 
			:} 
		| Champ:champ
			{: 
				List<FieldDeclaration> _champs = new LinkedList<FieldDeclaration>(); 
				_champs.add(champ); 
				RESULT = _champs; 
			:}
		;
		
Etiquette ::= UL_Identificateur:nom
				{: 
					RESULT = new LabelDeclaration( nom ); 
				:}
			;
		
Etiquettes ::= Etiquettes:etiquettes UL_Virgule Etiquette:etiquette
			{: 
				etiquettes.add(etiquette); 
				RESULT = etiquettes; 
			:} 
		| Etiquette:etiquette
			{: 
				List<LabelDeclaration> _etiquettes = new LinkedList<LabelDeclaration>(); 
				_etiquettes.add(etiquette); 
				RESULT = _etiquettes; 
			:}
		;
		
Atomique ::= UL_Type_Booleen
			{: 
				RESULT = AtomicType.BooleanType; 
			:}
		|	UL_Type_Caractere
			{: 
				RESULT = AtomicType.CharacterType; 
			:}
		|	UL_Type_Chaine
			{: 
				RESULT = AtomicType.StringType; 
			:}
		|	UL_Type_Entier
			{: 
				RESULT = AtomicType.IntegerType; 
			:}
/* Bloc :		|	UL_Type_Flottant
			{: 
				RESULT = AtomicType.FloatingType; 
			:} */
		|	UL_Type_Vide
			{: 
				RESULT = AtomicType.VoidType; 
			:}
		;
		
Type ::= Atomique:atomique
			{: 
				RESULT = atomique; 
			:}
		/*| UL_Identificateur:nom
			{: 
				RESULT = new NamedType( nom ); 
			:}
		*/	
		
		| Instanciation:instanciation 
			{:
				RESULT = new ClasseType(instanciation);
			:}	
		
/*	Bloc	| UL_Enregistrement UL_Identificateur:nom UL_Accolade_Ouvrante Champs:champs UL_Accolade_Fermante
			{: 
				RESULT = new RecordType( nom, champs ); 
			:}
		| UL_Enumeration UL_Identificateur:nom UL_Accolade_Ouvrante Etiquettes:etiquettes UL_Accolade_Fermante
			{: 
				RESULT = new EnumerationType( nom, etiquettes ); 
			:}
		| UL_Enregistrement UL_Identificateur:nom
			{: 
				RESULT = new NamedType( nom ); 
			:}
		| UL_Enumeration UL_Identificateur:nom
			{: 
				RESULT = new NamedType( nom ); 
			:}
		| UL_Inferieur Type:gauche UL_Virgule Type:droit UL_Superieur
			{:
				RESULT = new CoupleType( gauche, droit );
			:} */
		;

Instructions ::= Instructions:instructions Instruction:instruction
				{:
					instructions.add( instruction );
					RESULT = instructions; 
				:}
			|
				{: RESULT = new LinkedList<Instruction>(); :}
			;
			
Identifiant ::= UL_Identificateur:nom
				{: 
					RESULT = new Pair<String,PartialType>( nom, null ); 
				:}
/* Bloc			| UL_Asterisque Identifiant:identifiant 
				{:
					if (identifiant.getRight() == null) {
						identifiant.setRight( new PartialPointerType() );
					} else {
						identifiant.getRight().enrich(new PartialPointerType());
					}
					RESULT = identifiant;
				:} */
			| Identifiant:identifiant UL_Crochet_Ouvrant UL_Crochet_Fermant 
				{:
					if (identifiant.getRight() == null) {
						identifiant.setRight( new PartialArrayType() );
					} else {
						identifiant.getRight().enrich(new PartialArrayType());
					}
					RESULT = identifiant;
				:}
			| UL_Parenthese_Ouvrante Identifiant:identifiant UL_Parenthese_Fermante
				{:
					RESULT = identifiant;
				:}
			;
			
Parameters ::= Parameters:parameters UL_Virgule Type:type Identifiant:identifiant
				{:
					Type _type = identifiant.getRight();
					if (_type == null) {
						_type = type;
					} else {
						_type = ((PartialType)_type).complete( type );
 					}
					parameters.add( new ParameterDeclaration( identifiant.getLeft(), _type) );
					RESULT = parameters;
				:}
			| Type:type Identifiant:identifiant
				{:
					List<ParameterDeclaration> _parameters = new LinkedList<ParameterDeclaration>();
					Type _type = identifiant.getRight();
					if (_type == null) {
						_type = type;
					} else {
						_type = ((PartialType)_type).complete( type );
 					}
					_parameters.add( new ParameterDeclaration( identifiant.getLeft(), _type) );
					RESULT = _parameters;
				:}
			;
			
Declaration ::= Type:type Identifiant:identifiant UL_Egal Expression:valeur UL_Point_Virgule
				{:
					Type _type = identifiant.getRight();
					if (_type == null) {
						_type = type;
					} else {
						_type = ((PartialType)_type).complete( type );
 					}
					RESULT = new VariableDeclaration( identifiant.getLeft(), _type, valeur);
				:}
			| Type:type Identifiant:identifiant UL_Parenthese_Ouvrante Parameters:parametres UL_Parenthese_Fermante Bloc:corps
				{:
					Type _type = identifiant.getRight();
					if (_type == null) {
						_type = type;
					} else {
						_type = ((PartialType)_type).complete( type );
 					}
					RESULT = new FunctionDeclaration( identifiant.getLeft(), _type, parametres, corps);
 
				:}
			| Type:type Identifiant:identifiant UL_Parenthese_Ouvrante UL_Parenthese_Fermante Bloc:corps
				{:
					Type _type = identifiant.getRight();
					if (_type == null) {
						_type = type;
					} else {
						_type = ((PartialType)_type).complete( type );
 					}
					List<ParameterDeclaration> _parametres = new LinkedList<ParameterDeclaration>();
					RESULT = new FunctionDeclaration( identifiant.getLeft(), _type, _parametres, corps);
 
				:}
/* Bloc			| UL_Definition_Type Type:type Identifiant:identifiant UL_Point_Virgule
				{:
					Type _type = identifiant.getRight();
					if (_type == null) {
						_type = type;
					} else {
						_type = ((PartialType)_type).complete( type );
 					}
					RESULT = new TypeDeclaration( identifiant.getLeft(), _type); 
				:}
			| UL_Definition_Constante Type:type Identifiant:identifiant UL_Egal Expression:valeur UL_Point_Virgule
				{: 
					Type _type = identifiant.getRight();
					if (_type == null) {
						_type = type;
					} else {
						_type = ((PartialType)_type).complete( type );
 					}
					RESULT = new ConstantDeclaration( identifiant.getLeft(), _type, valeur); 
				:} */
			;

Instruction ::= Declaration:declaration
				{: 
					RESULT = declaration; 
				:}
			| Affectable:affectable UL_Egal Expression:expression UL_Point_Virgule
				{:
					RESULT = new Assignment( affectable, expression);
				:}
			| UL_Afficher Expression:expression UL_Point_Virgule
				{:
					RESULT = new Printer( expression );
				:}
			| UL_Si UL_Parenthese_Ouvrante Expression:condition UL_Parenthese_Fermante Bloc:alors UL_Sinon Bloc:sinon
				{: 
					RESULT = new Conditional( condition, alors, sinon); 
				:}
			| UL_Si UL_Parenthese_Ouvrante Expression:condition UL_Parenthese_Fermante Bloc:alors
				{: 
					RESULT = new Conditional( condition, alors); 
				:}
			| UL_Tant_Que UL_Parenthese_Ouvrante Expression:condition UL_Parenthese_Fermante Bloc:corps
				{: 
					RESULT = new Iteration( condition, corps); 
				:}
			| UL_Retour Expression:expression UL_Point_Virgule
				{:
					RESULT = new Return( expression, entCour);
				:}
			;
			
Expressions ::= Expressions:expressions UL_Virgule Expression:expression 	
				{:
					expressions.add( expression );
					RESULT = expressions; 
				:}
            | Expression:expression								
            		{: 
					List<Expression> _expressions = new LinkedList<Expression>();
					_expressions.add( expression );
					RESULT = _expressions;
				:}
            ;
            
Affectable ::= UL_Identificateur:nom
				{:
					RESULT = new VariableAssignment( nom );
				:}
/* Bloc			| UL_Asterisque Affectable:pointeur
				{:
					RESULT = new PointerAssignment( pointeur );
				:} */
			| Affectable:tableau UL_Crochet_Ouvrant Expression:indice UL_Crochet_Fermant
				{:
					RESULT = new ArrayAssignment( tableau, indice);
				:}
			| UL_Parenthese_Ouvrante Affectable:affectable UL_Parenthese_Fermante
				{:
					RESULT = affectable;
				:}
			/*
			| Affectable:enregistrement UL_Point UL_Identificateur:etiquette
				{:
					RESULT = new FieldAssignment( enregistrement, etiquette);
				:}
			*/
			| Affectable:objet UL_Point UL_Identificateur:attribut
				{:
					RESULT = new AttributAssignment(objet, attribut);
				:}
			| UL_This UL_Point  UL_Identificateur:attribut
				{:
					RESULT = new AttributPropreAssignment(nomCourant, attribut);
				:}
				
				
				
			/*| Affectable:objet UL_Point UL_Identificateur:methode UL_Parenthese_Ouvrante UL_Parenthese_Fermante
				{:
					RESULT = new MethodeAccess(objet, methode);
				:}*/
			;
			            
Expression ::= /* Affectable:affectable UL_Egal Expression:expression 
				{:
					RESULT = new Assignment( affectable, expression);
				:}
			| */ Expression:gauche UL_Double_Egal Expression:droite         
				{: 
					RESULT = new BinaryExpression( gauche, BinaryOperator.Equals, droite); 
				:}
			| Expression:gauche UL_Exclamation_Egal Expression:droite         
				{: 
					RESULT = new BinaryExpression( gauche, BinaryOperator.Different, droite); 
				:}
			| Expression:gauche UL_Inferieur Expression:droite         
				{: 
					RESULT = new BinaryExpression( gauche, BinaryOperator.Lesser, droite); 
				:}
			| Expression:gauche UL_Superieur Expression:droite         
				{: 
					RESULT = new BinaryExpression( gauche, BinaryOperator.Greater, droite); 
				:}
			| Expression:gauche UL_Inferieur_Egal Expression:droite         
				{: 
					RESULT = new BinaryExpression( gauche, BinaryOperator.LesserOrEqual, droite); 
				:}
			| Expression:gauche UL_Superieur_Egal Expression:droite         
				{: 
					RESULT = new BinaryExpression( gauche, BinaryOperator.GreaterOrEqual, droite); 
				:}
			| Expression:gauche UL_Double_Barre Expression:droite         
				{: 
					RESULT = new BinaryExpression( gauche, BinaryOperator.Or, droite); 
				:}
            | Expression:gauche UL_Double_Esperluette Expression:droite        	
             	{: 
					RESULT = new BinaryExpression( gauche, BinaryOperator.And, droite); 
				:}
			| Expression:gauche UL_Plus Expression:droite         
				{: 
					RESULT = new BinaryExpression( gauche, BinaryOperator.Add, droite); 
				:}
            | Expression:gauche UL_Moins Expression:droite        	
             	{: 
					RESULT = new BinaryExpression( gauche, BinaryOperator.Substract, droite); 
				:}
            | Expression:gauche UL_Asterisque Expression:droite        
             	{: 
					RESULT = new BinaryExpression( gauche, BinaryOperator.Multiply, droite); 
				:}
			| Expression:gauche UL_Oblique Expression:droite        
             	{: 
					RESULT = new BinaryExpression( gauche, BinaryOperator.Divide, droite); 
				:}
			| Expression:gauche UL_Pour_Cent Expression:droite        
             	{: 
					RESULT = new BinaryExpression( gauche, BinaryOperator.Modulo, droite); 
				:}
            | UL_Moins Expression:expression                 
             	{: 
					RESULT = new UnaryExpression( UnaryOperator.Opposite, expression); 
				:} 	
            | UL_Point_Exclamation Expression:expression                 
             	{: 
					RESULT = new UnaryExpression( UnaryOperator.Negate, expression); 
				:} 	
 /* Bloc           | UL_Esperluette Affectable:affectable                 
             	{: 
					RESULT = new AddressAccess( affectable ); 
				:} 	
			| UL_Asterisque Expression:expression                 
             	{: 
					RESULT = new PointerAccess( expression ); 
				:} 	
			| UL_Premier Expression:expression                 
             	{: 
					RESULT = new First( expression ); 
				:} 	
			| UL_Second Expression:expression                 
             	{: 
					RESULT = new Second( expression ); 
				:} 	*/
			| Expression:expression UL_Crochet_Ouvrant Expression:indice UL_Crochet_Fermant
				{:
					RESULT = new ArrayAccess( expression, indice );
				:}
			/*| Expression:expression UL_Point UL_Identificateur:etiquette
				{:
					RESULT = new FieldAccess( expression, etiquette );
				:} */
			| Expression:expression UL_Point UL_Identificateur:attribut
			{:
				RESULT = new AttributAccess(expression, attribut);
			:}
			| UL_This UL_Point UL_Identificateur:attribut
			{:
				RESULT = new AttributPropreAccess(nomCourant, attribut);
			:}
			| Expression:condition UL_Point_Interrogation Expression:alors UL_Deux_Points Expression:sinon
				{:
					RESULT = new ConditionalExpression( condition, alors, sinon);
				:}
			| UL_Parenthese_Ouvrante Expression:expression UL_Parenthese_Fermante	         
             	{: 
					RESULT = expression; 
				:}
			| UL_Parenthese_Ouvrante UL_Identificateur:type UL_Parenthese_Fermante Expression:expression    
             	{: 
					RESULT = new TypeConversion( expression, type); 
				:}
			| UL_Parenthese_Ouvrante Atomique:type UL_Parenthese_Fermante Expression:expression    
             	{: 
					RESULT = new TypeConversion( expression, type); 
				:}
			| UL_Accolade_Ouvrante Expressions:expressions UL_Accolade_Fermante	         
             	{: 
					RESULT = new Sequence( expressions ); 
				:}
/* Bloc			| UL_Inferieur Expression:premier UL_Virgule Expression:second UL_Superieur	         
             	{: 
					RESULT = new Couple( premier, second ); 
				:} */
			| UL_Identificateur:nom	                     
             	{: 
					RESULT = new IdentifierAccess( nom ); 
				:}
			| // Bloc : Appel de fonction simple
				UL_Identificateur:nom
				// MiniJava : Appel de méthode
				// Expression:objet
				UL_Parenthese_Ouvrante Expressions:parametres UL_Parenthese_Fermante                     
             	{: 
					RESULT = new FunctionCall( nom, parametres ); 
				:}
			| // Bloc : Appel de fonction simple
				UL_Identificateur:nom	
				// MiniJava : Appel de méthode
				// Expression:objet
				UL_Parenthese_Ouvrante UL_Parenthese_Fermante                     
             	{:
					List<Expression> _parametres = new LinkedList<Expression>();
					RESULT = new FunctionCall( nom, _parametres ); 
				:}
			| UL_Nombre_Entier:entier	                     
             	{: 
					RESULT = new IntegerValue( entier ); 
				:}
			| UL_Vrai                     
             	{: 
					RESULT = BooleanValue.True; 
				:}
			| UL_Faux                     
             	{: 
					RESULT = BooleanValue.False; 
				:}
			| UL_Nul	                     
             	{: 
					RESULT = NullValue.Null; 
				:}
/* Bloc			| UL_Nombre_Flottant:flottant	                     
             	{: 
					RESULT = new FloatingValue( flottant ); 
				:} */
			| UL_Caractere:caractere	                     
             	{: 
					RESULT = new CharacterValue( caractere ); 
				:}
			| UL_Chaine:chaine	                     
             	{: 
					RESULT = new StringValue( chaine ); 
				:}
			| UL_Nouveau Type:type UL_Crochet_Ouvrant Expression:taille UL_Crochet_Fermant	                     
             	{: 
					RESULT = new ArrayAllocation( type, taille ); 
				:}
			
			/*| UL_Nouveau Type:type UL_Parenthese_Ouvrante UL_Parenthese_Fermante	                     
             	{: 
					RESULT = new PointerAllocation( type ); 
				:} */
			| UL_Nouveau Type:type UL_Parenthese_Ouvrante UL_Parenthese_Fermante	                     
             	{: 
					ConstructeurCall cc = new ConstructeurCall(type, null);
					RESULT = new ClasseAllocation(type, cc); 
				:} 	
			| UL_Nouveau Type:type UL_Parenthese_Ouvrante Expressions:parametres UL_Parenthese_Fermante	                     
             	{: 
					ConstructeurCall cc = new ConstructeurCall(type, parametres);
					RESULT = new ClasseAllocation(type, cc); 
				:} 
			| Expression:objet UL_Point UL_Identificateur:methode UL_Parenthese_Ouvrante UL_Parenthese_Fermante
			{:
				RESULT = new MethodeCall(objet, methode, null);
			:}
			| Expression:objet UL_Point UL_Identificateur:methode UL_Parenthese_Ouvrante Expressions:parametres UL_Parenthese_Fermante
			{:
				RESULT = new MethodeCall(objet, methode, parametres);
			:}
            ;
       